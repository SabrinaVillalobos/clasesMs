"use strict";
 
//Carga de librerias
var soap = require('strong-soap').soap;
var QName = require('strong-soap').QName;
const clientesAlmacenados = new Map();
 
/**
* Genera cliente SOAP para realizar consulta al servicio seleccionado
*
* @param {string} url - URL del WSDL
* @param {string} header - Estructura completa de header en TRX (B9)
* @param {JSON} requestArgs - Estructura del body de la consulta
* @param {string} funcionWSDL - Nombre de función a llamar
* @callback callback - Nombre de función a llamar
*/

module.exports = (url, header, requestArgs, funcionWSDL, auth = {}) => {
  /**
   * Crea cliente SOAP para un WSDL en específico
   *
   * @param {string} url - URL del WSDL
   * @param {JSON} wsdlOption - Opciones básicas del WSDL
   * @callback requestCallback - Llamada a callback de manera asincrona
   */
  const clienteAlmacenado = clientesAlmacenados.get(url);
 
  var qname = new QName('{http://soa.bestado.cl/services/Header/v1.3}Trx');
  if (clienteAlmacenado) {
    return new Promise((resolve, reject) => {
      try {
        //Actualizacion de Header al cliente SOAP
        clienteAlmacenado.changeSoapHeader(0, header, qname);
        //Obteción del método del cliente
        var method = clienteAlmacenado[funcionWSDL[0]][funcionWSDL[1]][funcionWSDL[2]];
        method(requestArgs, (err, result, envelope, soapHeader) => {
 
          if (err) {
            return reject(err);
          } else {
            let requestJSON = {
              header: soapHeader,
              body: requestArgs,
            }
            let resultado = {
              requestJSON: requestJSON,
              result: result
            }
            return resolve(resultado);
          }
        });
 
      } catch (err) {
        let resp = {};
        ('' + err).search('Cannot read property') != 0 ? (
          resp = clientesAlmacenados
        ) : (
          resp = {
 
          }
        )
        return reject({
          "error": err
        }, {
          "resp": resp
        });
      }
    });
 
  } else {
    return new Promise((resolve, reject) => {
      soap.createClient(url, {}, (err, client) => {
        try {
          if (Object.keys(auth).length > 0) {
            if (typeof auth.username == "string" && typeof auth.password == "string") {
              let authorization = "Basic " + new Buffer(auth.username + ":" + auth.password).toString("base64");
              client.addHttpHeader('Authorization', authorization);
            } else {
              let error = "Usuario y contraseña deben ser tipo string";
              reject(error);
            }
          }
          //Debugg de request a realizar
          client.on('request', function (req) {
            //console.log(req);
          });
 
          //Guardamos clientes por url
          clientesAlmacenados.set(url, client);
 
          //Inserción de Header al cliente SOAP
          client.addSoapHeader(header, qname);
 
          //Obteción del método del cliente
          var method = client[funcionWSDL[0]][funcionWSDL[1]][funcionWSDL[2]];
          /**
           * Crea cliente SOAP para un WSDL en específico
           *
           * @param {JSON} requestArgs - Estructura del body de la consulta
           * @callback requestCallback - Llamada a callback de manera asincrona
           */
 
          method(requestArgs, (err, result, envelope, soapHeader) => {
            if (err) {
              return reject(err);
            } else {
              let requestJSON = {
                header: soapHeader,
                body: requestArgs,
              }
              let resultado = {
                requestJSON: requestJSON,
                result: result
              }
              return resolve(resultado);
            }
 
          });
 
        } catch (err) {
          let resp = {};
          ('' + err).search('Cannot read property') != 0 ? (
            resp = client
          ) : (
            resp = {
 
            }
          )
          return reject({
            "error": err
          }, {
            "resp": resp
          });
        }
      });
    });
  }
 
}