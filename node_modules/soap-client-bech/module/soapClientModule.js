//Carga de librerias
let soap = require('strong-soap').soap;
let QName = require('strong-soap').QName;

function soapClientModule(){

    /**
     * 
     * @param {String} url  URL de WSDL
     * @param {JSON} options definicion de timeout en milisegundos para respuesta del servicio ej : {timeout:3000}
     * @param {JSON} request JSON con la informacion de la peticion header y body ej: {header:'soy un header', body:'soy el body'}
     * @param {Array} funcionWSDL Arreglo con el 'servicio', 'binding' y 'operacion'
     */
    this.simpleSoapCall = (url,options,request,funcionWSDL)=> {
        let _timeout = options.timeout?options.timeout:0;
        return new Promise((resolve,reject) =>{
            try{
                soap.createClient(url,(err,client) => {
                    if(request.header != null){
                        client.addSoapHeader(request.header);
                    }
            
                    var method = client[funcionWSDL[0]][funcionWSDL[1]][funcionWSDL[2]];
                    method(request.body, (err, result) => {
                      if (err) {
                        return reject(err);
                      } else {
                        return resolve(result);
                      }
                    },{timeout:_timeout});
                });
            }catch(e){
                return reject(e);
            }
          })
    }

    /**
     * 
     * @param {String} url  URL de WSDL
     * @param {JSON} options definicion de timeout en milisegundos para respuesta del servicio ej : {timeout:3000}
     * @param {JSON} request JSON con la informacion de la peticion header y body ej: {header:'soy un header', body:'soy el body'}
     * @param {Array} funcionWSDL Arreglo con el 'servicio', 'binding' y 'operacion'
     */
    this.busSoapCall = (url,options,request,funcionWSDL) => {
        let _timeout = options.timeout?options.timeout:0;
        let qname = new QName('{http://soa.bestado.cl/services/Header/v1.3}Trx');
        return new Promise((resolve, reject) => {
            soap.createClient(url, {}, (err, client) => {
              try {
                if (options.auth != null && Object.keys(auth).length > 0) {
                  if (typeof auth.username == "string" && typeof auth.password == "string") {
                    let authorization = "Basic " + new Buffer(auth.username + ":" + auth.password).toString("base64");
                    client.addHttpHeader('Authorization', authorization);
                  } else {
                    let error = "Usuario y contraseña deben ser tipo string";
                    reject(error);
                  }
                }
                //Debugg de request a realizar
                client.on('request', function (req) {
                  //console.log(req);
                });
       
                //Inserción de Header al cliente SOAP
                client.addSoapHeader(request.header, qname);
       
                //Obteción del método del cliente
                var method = client[funcionWSDL[0]][funcionWSDL[1]][funcionWSDL[2]];
                /**
                 * Crea cliente SOAP para un WSDL en específico
                 *
                 * @param {JSON} requestArgs - Estructura del body de la consulta
                 * @callback requestCallback - Llamada a callback de manera asincrona
                 */
       
                method(request.body, (err, result, envelope, soapHeader) => {
                  if (err) {
                    return reject(err);
                  } else {
                    let requestJSON = {
                      header: soapHeader,
                      body: request.body,
                    }
                    let resultado = {
                      requestJSON: requestJSON,
                      result: result
                    }
                    return resolve(resultado);
                  }
       
                },{timeout:_timeout});
       
              } catch (err) {
                let resp = {};
                ('' + err).search('Cannot read property') != 0 ? (
                  resp = client
                ) : (
                  resp = {
       
                  }
                )
                return reject({
                  "error": err
                }, {
                  "resp": resp
                });
              }
            });
          });
    }

}

module.exports = soapClientModule;